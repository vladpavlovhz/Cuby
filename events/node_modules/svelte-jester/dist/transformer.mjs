import { execSync } from 'child_process';
import path, { extname, basename } from 'path';
import { pathToFileURL } from 'url';
import { VERSION, preprocess, compile } from 'svelte/compiler';
import fs from 'fs';

const configFilenames = ['svelte.config.js', 'svelte.config.cjs'];

function getSvelteConfig (rootMode, filename, preprocess) {
  let configFile = null;

  if (typeof preprocess === 'boolean') {
    configFile =
      rootMode === 'upward'
        ? findConfigFile(path.dirname(filename))
        : getConfigFile(process.cwd());
  } else if (typeof preprocess === 'string') {
    configFile = preprocess;
  }

  if (configFile === null || !fs.existsSync(configFile)) {
    throw Error(
      `Could not find ${configFilenames.join(' or ')} or ${configFile}.`
    )
  }

  return configFile
}

const getConfigFile = (searchDir) => {
  for (const configFilename of configFilenames) {
    const filePath = path.resolve(searchDir, configFilename);
    if (fs.existsSync(filePath)) {
      return filePath
    }
  }

  return null
};

const findConfigFile = (searchDir) => {
  const filePath = getConfigFile(searchDir);
  if (filePath !== null) {
    return filePath
  }

  const parentDir = path.resolve(searchDir, '..');
  return parentDir !== searchDir ? findConfigFile(parentDir) : null // Stop walking at filesystem root
};

const dynamicImport = async (filename) => import(pathToFileURL(filename).toString());

const IS_COMMON_JS = typeof module !== 'undefined';

const isSvelte3 = (version = VERSION) => version.startsWith('3');

const currentFileExtension = (global.__dirname !== undefined ? extname(__filename) : extname(pathToFileURL(import.meta.url).toString())).replace('.', '');

/**
 * Jest will only call this method when running in ESM mode.
 */
const processAsync = async (source, filename, jestOptions) => {
  const options = jestOptions && jestOptions.transformerConfig ? jestOptions.transformerConfig : {};
  const { preprocess: preprocess$1, rootMode, debug } = options;

  if (IS_COMMON_JS) {
    throw new Error('Running svelte-jester-transformer async in unsupported CJS mode')
  }

  if (debug) {
    console.debug(`Running svelte-jester-transformer async in mode ${currentFileExtension}.`);
  }

  if (!preprocess$1) {
    return compiler('esm', options, filename, source)
  }

  const svelteConfigPath = getSvelteConfig(rootMode, filename, preprocess$1);
  const svelteConfig = await dynamicImport(svelteConfigPath);
  const processed = await preprocess(
    source,
    svelteConfig.default.preprocess || {},
    { filename }
  );

  return compiler('esm', options, filename, processed.code, processed.map)
};

/**
 * Starts a new process, so it has a higher overhead than processAsync.
 * However, Jest calls this method in CJS mode.
 */
const processSync = (source, filename, jestOptions) => {
  const options = jestOptions && jestOptions.transformerConfig ? jestOptions.transformerConfig : {};
  const { preprocess, rootMode, maxBuffer, showConsoleLog, debug, svelteVersion } = options;

  if (!isSvelte3(svelteVersion)) {
    throw new Error('Jest is being called in CJS mode. You must use ESM mode in Svelte 4+')
  }

  if (!IS_COMMON_JS) {
    throw new Error('Running svelte-jester-transformer sync in unsupported ESM mode')
  }

  if (debug) {
    console.debug(`Running svelte-jester-transformer sync in mode ${currentFileExtension}.`);
  }

  if (!preprocess) {
    return compiler('cjs', options, filename, source)
  }

  const svelteConfig = getSvelteConfig(rootMode, filename, preprocess);
  const preprocessor = require.resolve('./preprocess.js');

  const preprocessResult = execSync(
        `node --unhandled-rejections=strict --abort-on-uncaught-exception "${preprocessor}"`,
        {
          env: { ...process.env, source, filename, svelteConfig, showConsoleLog },
          maxBuffer: maxBuffer || 10 * 1024 * 1024
        }
  ).toString();

  const parsedPreprocessResult = JSON.parse(preprocessResult);
  return compiler('cjs', options, filename, parsedPreprocessResult.code, parsedPreprocessResult.map)
};

const compiler = (format, options = {}, filename, processedCode, processedMap) => {
  const opts = {
    filename: basename(filename),
    css: isSvelte3(options.svelteVersion) ? true : 'injected',
    accessors: true,
    dev: true,
    sourcemap: processedMap,
    ...options.compilerOptions
  };

  if (isSvelte3(options.svelteVersion)) {
    opts.format = format;
  }

  let result;
  try {
    result = compile(processedCode, opts);
  } catch (error) {
    let msg = error.message;
    if (error.frame) {
      msg += '\n' + error.frame;
    }
    console.error(msg);
    throw error
  }

  if (options.debug) {
    console.log(result.js.code);
  }

  const esInterop = format === 'cjs' ? 'Object.defineProperty(exports, "__esModule", { value: true });' : '';

  return {
    code: result.js.code + esInterop,
    map: JSON.stringify(result.js.map)
  }
};

var transformer = {
  process: processSync,
  processAsync
};

export { transformer as default };
